<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2c3e50, #3498db);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
        }
        
        #gameContainer {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }
        
        canvas {
            border: 3px solid #34495e;
            border-radius: 10px;
            background: #27ae60;
            display: block;
        }
        
        #ui {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 15px;
            width: 800px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 10px;
        }
        
        .stats {
            display: flex;
            gap: 20px;
        }
        
        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
        }
        
        .towers {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .tower-btn {
            background: linear-gradient(145deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            position: relative;
            font-size: 12px;
        }
        
        .tower-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .tower-btn.cannon { background: linear-gradient(145deg, #e74c3c, #c0392b); }
        .tower-btn.laser { background: linear-gradient(145deg, #3498db, #2980b9); }
        .tower-btn.missile { background: linear-gradient(145deg, #9b59b6, #8e44ad); }
        .tower-btn.sniper { background: linear-gradient(145deg, #2c3e50, #34495e); }
        .tower-btn.freeze { background: linear-gradient(145deg, #74b9ff, #0984e3); }
        .tower-btn.plasma { background: linear-gradient(145deg, #a29bfe, #6c5ce7); }
        .tower-btn.electric { background: linear-gradient(145deg, #fdcb6e, #e17055); }
        .tower-btn.poison { background: linear-gradient(145deg, #00b894, #00a085); }
        
        .tower-btn.selected {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
            transform: scale(1.1);
        }
        
        #towerControls {
            margin-top: 10px;
            text-align: center;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 10px;
        }
        
        #controls {
            margin-top: 10px;
            text-align: center;
        }
        
        .control-btn {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            color: white;
            border: none;
            padding: 12px 25px;
            margin: 0 5px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .tooltip {
            font-size: 12px;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
        }
        
        @keyframes floatUp {
            0% { 
                opacity: 1; 
                transform: translateY(0px); 
            }
            100% { 
                opacity: 0; 
                transform: translateY(-50px); 
            }
        }
    </style>
</head>
<body>
    <h1>üè∞ Tower Defense</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui">
            <div class="stats">
                <div class="stat">üí∞ Gold: <span id="gold">75</span></div>
                <div class="stat">‚ù§Ô∏è Lives: <span id="lives">20</span></div>
                <div class="stat">üåä Wave: <span id="wave">1</span></div>
                <div class="stat">üëπ Enemies: <span id="enemies">0</span></div>
            </div>
            <div class="towers" id="towersContainer">
                <!-- Towers will be dynamically added here -->
            </div>
        </div>
        <div id="towerControls" style="display: none;">
            <div style="margin-bottom: 10px; color: white;">
                <span id="towerInfo">Selected Tower</span>
            </div>
            <button class="control-btn" onclick="upgradeTower()" id="upgradeBtn">
                ‚¨ÜÔ∏è Upgrade
            </button>
            <button class="control-btn" onclick="sellTower()" id="sellBtn">
                üí∞ Sell
            </button>
            <button class="control-btn" onclick="deselectTower()">
                ‚ùå Close
            </button>
        </div>
        <div id="controls">
            <button class="control-btn" onclick="startWave()">üåä Start Wave</button>
            <button class="control-btn" onclick="togglePause()">‚è∏Ô∏è Pause</button>
            <button class="control-btn" onclick="resetGame()">üîÑ Reset</button>
        </div>
        <div class="tooltip">
            Click to place towers ‚Ä¢ Click towers to upgrade/sell ‚Ä¢ New enemies every 5 waves ‚Ä¢ Electric towers chain lightning! ‚Ä¢ Poison towers damage over time!
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = {
            gold: 75,
            lives: 20,
            wave: 1,
            selectedTower: null,
            selectedPlacedTower: null,
            enemies: [],
            towers: [],
            projectiles: [],
            particles: [],
            lightningEffects: [],
            gameRunning: false,
            paused: false,
            waveInProgress: false,
            enemiesSpawned: 0,
            enemiesInWave: 8
        };
        
        // Extended path with properly spaced parallel sections for tower placement
        const path = [
            {x: 0, y: 100},
            {x: 80, y: 100},      
            {x: 80, y: 200},      
            {x: 220, y: 200},     
            {x: 220, y: 60},      
            {x: 350, y: 60},      
            {x: 350, y: 180},     
            {x: 450, y: 180},
            {x: 450, y: 300},
            {x: 580, y: 300},
            {x: 580, y: 130},     
            {x: 680, y: 130},
            {x: 680, y: 350},     
            {x: 750, y: 350},
            {x: 750, y: 480},
            {x: 620, y: 480},
            {x: 620, y: 520},     
            {x: 350, y: 520},     
            {x: 350, y: 400},     
            {x: 220, y: 400},     
            {x: 220, y: 340},     
            {x: 80, y: 340},      
            {x: 80, y: 470},      
            {x: 50, y: 470},
            {x: 50, y: 570},      
            {x: 800, y: 570}
        ];
        
        // Tower types - updated unlock progression
        const towerTypes = {
            cannon: {
                cost: 25,
                damage: 20,
                range: 90,
                fireRate: 900,
                color: '#e74c3c',
                projectileSpeed: 4,
                size: 20,
                unlocked: true
            },
            laser: {
                cost: 45,
                damage: 12,
                range: 130,
                fireRate: 350,
                color: '#3498db',
                projectileSpeed: 6,
                size: 18,
                unlocked: true
            },
            missile: {
                cost: 70,
                damage: 35,
                range: 110,
                fireRate: 1500,
                color: '#9b59b6',
                projectileSpeed: 3,
                size: 22,
                aoe: true,
                aoeRadius: 35,
                unlocked: true
            },
            sniper: {
                cost: 120,
                damage: 80,
                range: 200,
                fireRate: 2000,
                color: '#2c3e50',
                projectileSpeed: 10,
                size: 16,
                unlocked: true
            },
            poison: {
                cost: 65,
                damage: 8,
                range: 95,
                fireRate: 1000,
                color: '#00b894',
                projectileSpeed: 5,
                size: 18,
                special: 'poison',
                poisonDamage: 3,
                poisonDuration: 180,
                unlocked: false,
                unlockWave: 10
            },
            freeze: {
                cost: 90,
                damage: 5,
                range: 100,
                fireRate: 800,
                color: '#74b9ff',
                projectileSpeed: 5,
                size: 18,
                special: 'freeze',
                unlocked: false,
                unlockWave: 20
            },
            plasma: {
                cost: 150,
                damage: 60,
                range: 120,
                fireRate: 1200,
                color: '#a29bfe',
                projectileSpeed: 7,
                size: 20,
                piercing: true,
                unlocked: false,
                unlockWave: 30
            },
            electric: {
                cost: 110,
                damage: 25,
                range: 100,
                fireRate: 1000,
                color: '#fdcb6e',
                projectileSpeed: 8,
                size: 19,
                special: 'chain',
                chainRange: 60,
                maxChains: 3,
                unlocked: false,
                unlockWave: 35
            }
        };
        
        // Enemy types
        const enemyTypes = {
            basic: {
                health: 1,
                speed: 1,
                reward: 1,
                color: '#e74c3c',
                size: 15,
                unlocked: true
            },
            fast: {
                health: 0.7,
                speed: 1.8,
                reward: 1.2,
                color: '#f39c12',
                size: 12,
                unlocked: false,
                unlockWave: 5
            },
            heavy: {
                health: 2.5,
                speed: 0.6,
                reward: 1.8,
                color: '#8e44ad',
                size: 20,
                unlocked: false,
                unlockWave: 10
            },
            armored: {
                health: 2,
                speed: 0.8,
                reward: 2,
                color: '#34495e',
                size: 18,
                armor: 0.5,
                unlocked: false,
                unlockWave: 15
            },
            flying: {
                health: 1.2,
                speed: 1.4,
                reward: 1.5,
                color: '#16a085',
                size: 14,
                flying: true,
                unlocked: false,
                unlockWave: 20
            },
            boss: {
                health: 8,
                speed: 0.4,
                reward: 5,
                color: '#c0392b',
                size: 30,
                unlocked: false,
                unlockWave: 25
            }
        };
        
        // Lightning Effect class
        class LightningEffect {
            constructor(x1, y1, x2, y2) {
                this.x1 = x1;
                this.y1 = y1;
                this.x2 = x2;
                this.y2 = y2;
                this.life = 15;
                this.segments = this.generateSegments();
            }
            
            generateSegments() {
                const segments = [];
                const numSegments = 8;
                const dx = (this.x2 - this.x1) / numSegments;
                const dy = (this.y2 - this.y1) / numSegments;
                
                let currentX = this.x1;
                let currentY = this.y1;
                
                for (let i = 0; i < numSegments; i++) {
                    const nextX = this.x1 + dx * (i + 1) + (Math.random() - 0.5) * 20;
                    const nextY = this.y1 + dy * (i + 1) + (Math.random() - 0.5) * 20;
                    
                    segments.push({
                        x1: currentX,
                        y1: currentY,
                        x2: nextX,
                        y2: nextY
                    });
                    
                    currentX = nextX;
                    currentY = nextY;
                }
                
                segments[segments.length - 1].x2 = this.x2;
                segments[segments.length - 1].y2 = this.y2;
                
                return segments;
            }
            
            update() {
                this.life--;
                return this.life > 0;
            }
            
            draw() {
                const alpha = this.life / 15;
                ctx.globalAlpha = alpha;
                ctx.strokeStyle = '#fdcb6e';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#fdcb6e';
                ctx.shadowBlur = 10;
                
                for (let segment of this.segments) {
                    ctx.beginPath();
                    ctx.moveTo(segment.x1, segment.y1);
                    ctx.lineTo(segment.x2, segment.y2);
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#fff';
                for (let segment of this.segments) {
                    if (Math.random() < 0.3) {
                        ctx.beginPath();
                        ctx.arc(segment.x2, segment.y2, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }
        
        // Enemy class
        class Enemy {
            constructor(type = 'basic') {
                this.type = type;
                const baseHealth = 55 + (gameState.wave - 1) * 40;
                const baseSpeed = 0.9 + Math.random() * 0.3 + (gameState.wave - 1) * 0.12;
                const baseReward = 9 + Math.floor(gameState.wave * 1.8);
                
                const enemyType = enemyTypes[type];
                this.health = Math.floor(baseHealth * enemyType.health);
                this.maxHealth = this.health;
                this.speed = baseSpeed * enemyType.speed;
                this.reward = Math.floor(baseReward * enemyType.reward);
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.size = enemyType.size;
                this.color = enemyType.color;
                this.armor = enemyType.armor || 0;
                this.flying = enemyType.flying || false;
                this.frozen = 0;
                this.originalSpeed = this.speed;
                this.stunned = 0;
                this.poisoned = 0;
                this.poisonDamage = 0;
            }
            
            update() {
                if (this.frozen > 0) {
                    this.frozen--;
                    this.speed = this.originalSpeed * 0.3;
                } else if (this.stunned > 0) {
                    this.stunned--;
                    this.speed = this.originalSpeed * 0.1;
                } else {
                    this.speed = this.originalSpeed;
                }
                
                if (this.poisoned > 0) {
                    this.poisoned--;
                    if (this.poisoned % 30 === 0) {
                        this.health -= this.poisonDamage;
                        
                        for (let i = 0; i < 3; i++) {
                            gameState.particles.push(new Particle(
                                this.x + (Math.random() - 0.5) * this.size,
                                this.y + (Math.random() - 0.5) * this.size,
                                (Math.random() - 0.5) * 2,
                                (Math.random() - 0.5) * 2,
                                '#00b894'
                            ));
                        }
                        
                        if (this.health <= 0) {
                            gameState.gold += this.reward;
                            this.createDeathParticles();
                            const index = gameState.enemies.indexOf(this);
                            if (index > -1) gameState.enemies.splice(index, 1);
                            return false;
                        }
                    }
                }
                
                if (this.pathIndex >= path.length - 1) {
                    this.reachEnd();
                    return false;
                }
                
                const target = path[this.pathIndex + 1];
                const dx = target.x - this.x;
                const dy = target.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < 5) {
                    this.pathIndex++;
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }
                
                return this.health > 0;
            }
            
            takeDamage(damage, special = null, poisonDamage = 0, poisonDuration = 0) {
                const finalDamage = damage * (1 - this.armor);
                this.health -= finalDamage;
                
                if (special === 'freeze') {
                    this.frozen = 60;
                } else if (special === 'chain') {
                    this.stunned = 30;
                } else if (special === 'poison') {
                    this.poisoned = Math.max(this.poisoned, poisonDuration);
                    this.poisonDamage = Math.max(this.poisonDamage, poisonDamage);
                }
                
                if (this.health <= 0) {
                    gameState.gold += this.reward;
                    this.createDeathParticles();
                    return true;
                }
                return false;
            }
            
            reachEnd() {
                gameState.lives--;
                updateUI();
                if (gameState.lives <= 0) {
                    alert('Game Over! You defended for ' + gameState.wave + ' waves!');
                    resetGame();
                }
            }
            
            createDeathParticles() {
                for (let i = 0; i < 8; i++) {
                    gameState.particles.push(new Particle(
                        this.x, this.y, 
                        Math.random() * 4 - 2, 
                        Math.random() * 4 - 2,
                        this.color
                    ));
                }
            }
            
            draw() {
                let drawY = this.y;
                if (this.flying) {
                    drawY += Math.sin(Date.now() * 0.01 + this.x * 0.1) * 3;
                }
                
                ctx.fillStyle = this.color;
                if (this.frozen > 0) {
                    ctx.fillStyle = '#74b9ff';
                } else if (this.stunned > 0) {
                    ctx.fillStyle = '#fdcb6e';
                } else if (this.poisoned > 0) {
                    ctx.fillStyle = Math.floor(Date.now() / 200) % 2 ? this.color : '#00b894';
                }
                
                ctx.beginPath();
                ctx.arc(this.x, drawY, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.stunned > 0) {
                    ctx.strokeStyle = '#fdcb6e';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#fdcb6e';
                    ctx.shadowBlur = 5;
                    ctx.beginPath();
                    ctx.arc(this.x, drawY, this.size + 5 + Math.sin(Date.now() * 0.02) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                if (this.poisoned > 0) {
                    ctx.fillStyle = 'rgba(0, 184, 148, 0.6)';
                    for (let i = 0; i < 3; i++) {
                        const angle = (Date.now() * 0.01 + i * Math.PI * 2 / 3) % (Math.PI * 2);
                        const bubbleRadius = 3 + Math.sin(Date.now() * 0.02 + i) * 1;
                        const distance = this.size + 8;
                        ctx.beginPath();
                        ctx.arc(
                            this.x + Math.cos(angle) * distance,
                            drawY + Math.sin(angle) * distance,
                            bubbleRadius, 0, Math.PI * 2
                        );
                        ctx.fill();
                    }
                }
                
                if (this.armor > 0) {
                    ctx.strokeStyle = '#34495e';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, drawY, this.size - 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                if (this.flying) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.ellipse(this.x, drawY + this.size + 5, this.size * 0.8, 4, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                const barWidth = this.size * 2;
                const barHeight = 4;
                const healthRatio = this.health / this.maxHealth;
                
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - barWidth/2, drawY - this.size - 10, barWidth, barHeight);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x - barWidth/2, drawY - this.size - 10, barWidth * healthRatio, barHeight);
                
                if (this.type !== 'boss') {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(this.x - this.size/3, drawY - this.size/4, this.size/5, 0, Math.PI * 2);
                    ctx.arc(this.x + this.size/3, drawY - this.size/4, this.size/5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(this.x - this.size/3, drawY - this.size/4, this.size/8, 0, Math.PI * 2);
                    ctx.arc(this.x + this.size/3, drawY - this.size/4, this.size/8, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Tower class
        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.level = 1;
                this.stats = {...towerTypes[type]};
                this.totalCost = this.stats.cost;
                this.lastFire = 0;
                this.target = null;
                this.angle = 0;
            }
            
            upgrade() {
                if (this.level >= 3) return false;
                
                const upgradeCost = this.getUpgradeCost();
                if (gameState.gold < upgradeCost) return false;
                
                gameState.gold -= upgradeCost;
                this.totalCost += upgradeCost;
                this.level++;
                
                const multiplier = 1 + (this.level - 1) * 0.5;
                const baseStats = towerTypes[this.type];
                this.stats.damage = Math.floor(baseStats.damage * multiplier);
                this.stats.range = Math.floor(baseStats.range * (1 + (this.level - 1) * 0.3));
                this.stats.fireRate = Math.floor(baseStats.fireRate * (1 - (this.level - 1) * 0.2));
                
                if (this.type === 'electric') {
                    this.stats.maxChains = baseStats.maxChains + (this.level - 1);
                    this.stats.chainRange = Math.floor(baseStats.chainRange * (1 + (this.level - 1) * 0.2));
                } else if (this.type === 'poison') {
                    this.stats.poisonDamage = Math.floor(baseStats.poisonDamage * (1 + (this.level - 1) * 0.5));
                    this.stats.poisonDuration = Math.floor(baseStats.poisonDuration * (1 + (this.level - 1) * 0.3));
                }
                
                return true;
            }
            
            getUpgradeCost() {
                return Math.floor(this.stats.cost * (0.7 + this.level * 0.3));
            }
            
            getSellValue() {
                return Math.floor(this.totalCost * 0.6);
            }
            
            update() {
                this.findTarget();
                if (this.target && Date.now() - this.lastFire > this.stats.fireRate) {
                    this.fire();
                    this.lastFire = Date.now();
                }
            }
            
            findTarget() {
                let closest = null;
                let closestDist = this.stats.range;
                
                for (let enemy of gameState.enemies) {
                    const dist = Math.sqrt(
                        Math.pow(enemy.x - this.x, 2) + 
                        Math.pow(enemy.y - this.y, 2)
                    );
                    
                    if (dist < closestDist) {
                        closest = enemy;
                        closestDist = dist;
                    }
                }
                
                this.target = closest;
                if (this.target) {
                    this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                }
            }
            
            fire() {
                if (!this.target) return;
                
                if (this.type === 'electric') {
                    this.fireChainLightning();
                } else if (this.type === 'poison') {
                    this.firePoisonCloud();
                } else {
                    gameState.projectiles.push(new Projectile(
                        this.x, this.y, this.target, this.stats, this.type
                    ));
                }
            }
            
            firePoisonCloud() {
                const cloudRadius = 60;
                
                for (let i = 0; i < 15; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * cloudRadius;
                    gameState.particles.push(new Particle(
                        this.target.x + Math.cos(angle) * distance,
                        this.target.y + Math.sin(angle) * distance,
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 2 - 1,
                        '#00b894'
                    ));
                }
                
                for (let enemy of gameState.enemies) {
                    const dist = Math.sqrt(
                        Math.pow(enemy.x - this.target.x, 2) + 
                        Math.pow(enemy.y - this.target.y, 2)
                    );
                    
                    if (dist < cloudRadius) {
                        if (enemy.takeDamage(
                            this.stats.damage, 
                            this.stats.special,
                            this.stats.poisonDamage,
                            this.stats.poisonDuration
                        )) {
                            const index = gameState.enemies.indexOf(enemy);
                            if (index > -1) gameState.enemies.splice(index, 1);
                        }
                    }
                }
            }
            
            fireChainLightning() {
                const hitEnemies = [];
                let currentTarget = this.target;
                let chainCount = 0;
                let lastPos = {x: this.x, y: this.y};
                
                while (currentTarget && chainCount < this.stats.maxChains) {
                    hitEnemies.push(currentTarget);
                    
                    gameState.lightningEffects.push(new LightningEffect(
                        lastPos.x, lastPos.y, currentTarget.x, currentTarget.y
                    ));
                    
                    const damage = this.stats.damage * (1 - chainCount * 0.2);
                    if (currentTarget.takeDamage(damage, this.stats.special)) {
                        const index = gameState.enemies.indexOf(currentTarget);
                        if (index > -1) gameState.enemies.splice(index, 1);
                    }
                    
                    lastPos = {x: currentTarget.x, y: currentTarget.y};
                    let nextTarget = null;
                    let closestDist = this.stats.chainRange;
                    
                    for (let enemy of gameState.enemies) {
                        if (hitEnemies.includes(enemy)) continue;
                        
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - currentTarget.x, 2) + 
                            Math.pow(enemy.y - currentTarget.y, 2)
                        );
                        
                        if (dist < closestDist) {
                            nextTarget = enemy;
                            closestDist = dist;
                        }
                    }
                    
                    currentTarget = nextTarget;
                    chainCount++;
                }
            }
            
            draw() {
                const isSelected = gameState.selectedPlacedTower === this;
                
                ctx.fillStyle = isSelected ? '#f39c12' : '#34495e';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.stats.size + 5, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = this.stats.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.stats.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.type === 'electric') {
                    ctx.strokeStyle = '#fdcb6e';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#fdcb6e';
                    ctx.shadowBlur = 5;
                    ctx.setLineDash([2, 2]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.size + 3 + Math.sin(Date.now() * 0.01) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    
                    if (Math.random() < 0.3) {
                        ctx.fillStyle = '#fff';
                        for (let i = 0; i < 3; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = this.stats.size + Math.random() * 10;
                            ctx.beginPath();
                            ctx.arc(
                                this.x + Math.cos(angle) * dist,
                                this.y + Math.sin(angle) * dist,
                                1, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                }
                
                if (this.type === 'poison') {
                    ctx.strokeStyle = '#00b894';
                    ctx.lineWidth = 2;
                    ctx.shadowColor = '#00b894';
                    ctx.shadowBlur = 5;
                    ctx.setLineDash([3, 2]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.size + 4 + Math.sin(Date.now() * 0.008) * 2, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    ctx.shadowBlur = 0;
                    
                    if (Math.random() < 0.2) {
                        ctx.fillStyle = 'rgba(0, 184, 148, 0.6)';
                        for (let i = 0; i < 2; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = this.stats.size + Math.random() * 15;
                            ctx.beginPath();
                            ctx.arc(
                                this.x + Math.cos(angle) * dist,
                                this.y + Math.sin(angle) * dist,
                                2 + Math.random() * 2, 0, Math.PI * 2
                            );
                            ctx.fill();
                        }
                    }
                }
                
                if (this.level > 1) {
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(this.level, this.x, this.y - this.stats.size - 10);
                }
                
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(
                    this.x + Math.cos(this.angle) * (this.stats.size + 10),
                    this.y + Math.sin(this.angle) * (this.stats.size + 10)
                );
                ctx.stroke();
                
                if (isSelected) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.range, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.stats.size + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    if (this.type === 'electric' && this.target) {
                        ctx.strokeStyle = 'rgba(253, 203, 110, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, this.stats.chainRange, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    
                    if (this.type === 'poison' && this.target) {
                        ctx.strokeStyle = 'rgba(0, 184, 148, 0.3)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([3, 3]);
                        ctx.beginPath();
                        ctx.arc(this.target.x, this.target.y, 60, 0, Math.PI * 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                }
            }
        }
        
        // Projectile class
        class Projectile {
            constructor(x, y, target, stats, type) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = stats.damage;
                this.speed = stats.projectileSpeed;
                this.type = type;
                this.aoe = stats.aoe;
                this.aoeRadius = stats.aoeRadius;
                this.special = stats.special;
                this.piercing = stats.piercing;
                this.size = 4;
                this.pierced = [];
                
                const dx = target.x - x;
                const dy = target.y - y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                
                for (let enemy of gameState.enemies) {
                    if (this.piercing && this.pierced.includes(enemy)) continue;
                    
                    const dist = Math.sqrt(
                        Math.pow(enemy.x - this.x, 2) + 
                        Math.pow(enemy.y - this.y, 2)
                    );
                    
                    if (dist < enemy.size + this.size) {
                        if (this.piercing) {
                            this.pierced.push(enemy);
                            if (enemy.takeDamage(this.damage, this.special)) {
                                gameState.enemies.splice(gameState.enemies.indexOf(enemy), 1);
                            }
                            if (this.pierced.length >= 3) {
                                return false;
                            }
                        } else {
                            this.explode();
                            return false;
                        }
                    }
                }
                
                return this.x > -50 && this.x < canvas.width + 50 && 
                       this.y > -50 && this.y < canvas.height + 50;
            }
            
            explode() {
                if (this.aoe) {
                    for (let enemy of gameState.enemies) {
                        const dist = Math.sqrt(
                            Math.pow(enemy.x - this.x, 2) + 
                            Math.pow(enemy.y - this.y, 2)
                        );
                        
                        if (dist < this.aoeRadius) {
                            if (enemy.takeDamage(this.damage, this.special)) {
                                gameState.enemies.splice(gameState.enemies.indexOf(enemy), 1);
                            }
                        }
                    }
                    
                    for (let i = 0; i < 15; i++) {
                        gameState.particles.push(new Particle(
                            this.x, this.y,
                            Math.random() * 6 - 3,
                            Math.random() * 6 - 3,
                            '#ff6b6b'
                        ));
                    }
                } else {
                    if (this.target && gameState.enemies.includes(this.target)) {
                        if (this.target.takeDamage(this.damage, this.special)) {
                            gameState.enemies.splice(gameState.enemies.indexOf(this.target), 1);
                        }
                    }
                }
            }
            
            draw() {
                if (this.type === 'laser') {
                    ctx.fillStyle = '#3498db';
                    ctx.shadowColor = '#3498db';
                    ctx.shadowBlur = 10;
                } else if (this.type === 'missile') {
                    ctx.fillStyle = '#9b59b6';
                    ctx.shadowColor = '#9b59b6';
                    ctx.shadowBlur = 8;
                } else if (this.type === 'sniper') {
                    ctx.fillStyle = '#2c3e50';
                    ctx.shadowColor = '#2c3e50';
                    ctx.shadowBlur = 12;
                    this.size = 6;
                } else if (this.type === 'freeze') {
                    ctx.fillStyle = '#74b9ff';
                    ctx.shadowColor = '#74b9ff';
                    ctx.shadowBlur = 8;
                } else if (this.type === 'plasma') {
                    ctx.fillStyle = '#a29bfe';
                    ctx.shadowColor = '#a29bfe';
                    ctx.shadowBlur = 15;
                    this.size = 5;
                } else {
                    ctx.fillStyle = '#e74c3c';
                    ctx.shadowColor = '#e74c3c';
                    ctx.shadowBlur = 5;
                }
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
            }
        }
        
        // Particle class
        class Particle {
            constructor(x, y, vx, vy, color) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.life = 1;
                this.decay = 0.02;
                this.size = Math.random() * 4 + 2;
            }
            
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.life -= this.decay;
                this.vx *= 0.98;
                this.vy *= 0.98;
                return this.life > 0;
            }
            
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }
        
        // Game functions
        function selectTower(type) {
            gameState.selectedTower = gameState.selectedTower === type ? null : type;
            gameState.selectedPlacedTower = null;
            updateTowerButtons();
            updateTowerControls();
        }
        
        function selectPlacedTower(tower) {
            gameState.selectedPlacedTower = gameState.selectedPlacedTower === tower ? null : tower;
            gameState.selectedTower = null;
            updateTowerButtons();
            updateTowerControls();
        }
        
        function deselectTower() {
            gameState.selectedPlacedTower = null;
            updateTowerControls();
        }
        
        function upgradeTower() {
            if (gameState.selectedPlacedTower && gameState.selectedPlacedTower.upgrade()) {
                updateTowerControls();
                updateUI();
            }
        }
        
        function sellTower() {
            if (gameState.selectedPlacedTower) {
                gameState.gold += gameState.selectedPlacedTower.getSellValue();
                const index = gameState.towers.indexOf(gameState.selectedPlacedTower);
                gameState.towers.splice(index, 1);
                gameState.selectedPlacedTower = null;
                updateTowerControls();
                updateUI();
            }
        }
        
        function updateTowerControls() {
            const controlsDiv = document.getElementById('towerControls');
            const towerInfo = document.getElementById('towerInfo');
            const upgradeBtn = document.getElementById('upgradeBtn');
            const sellBtn = document.getElementById('sellBtn');
            
            if (gameState.selectedPlacedTower) {
                const tower = gameState.selectedPlacedTower;
                controlsDiv.style.display = 'block';
                
                let extraInfo = '';
                if (tower.type === 'electric') {
                    extraInfo = ` | Chains: ${tower.stats.maxChains}`;
                } else if (tower.type === 'poison') {
                    extraInfo = ` | Poison: ${tower.stats.poisonDamage}/tick for ${Math.floor(tower.stats.poisonDuration/60)}s`;
                }
                
                towerInfo.innerHTML = `
                    <strong>${tower.type.toUpperCase()} Tower (Level ${tower.level})</strong><br>
                    Damage: ${tower.stats.damage} | Range: ${tower.stats.range} | Fire Rate: ${(1000/tower.stats.fireRate).toFixed(1)}/s${extraInfo}
                `;
                
                if (tower.level >= 3) {
                    upgradeBtn.textContent = '‚¨ÜÔ∏è MAX LEVEL';
                    upgradeBtn.disabled = true;
                    upgradeBtn.style.opacity = '0.5';
                } else {
                    const upgradeCost = tower.getUpgradeCost();
                    upgradeBtn.textContent = `‚¨ÜÔ∏è Upgrade (${upgradeCost})`;
                    upgradeBtn.disabled = gameState.gold < upgradeCost;
                    upgradeBtn.style.opacity = gameState.gold < upgradeCost ? '0.5' : '1';
                }
                
                const sellValue = tower.getSellValue();
                sellBtn.textContent = `üí∞ Sell (${sellValue})`;
            } else {
                controlsDiv.style.display = 'none';
            }
        }
        
        function updateTowerButtons() {
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            if (gameState.selectedTower) {
                const selectedBtn = document.querySelector(`.tower-btn.${gameState.selectedTower}`);
                if (selectedBtn) selectedBtn.classList.add('selected');
            }
        }
        
        function placeTower(x, y) {
            for (let tower of gameState.towers) {
                const dist = Math.sqrt(Math.pow(tower.x - x, 2) + Math.pow(tower.y - y, 2));
                if (dist < tower.stats.size + 10) {
                    selectPlacedTower(tower);
                    return;
                }
            }
            
            if (!gameState.selectedTower) return;
            
            const towerType = towerTypes[gameState.selectedTower];
            if (gameState.gold < towerType.cost) return;
            
            if (isValidTowerPosition(x, y)) {
                gameState.towers.push(new Tower(x, y, gameState.selectedTower));
                gameState.gold -= towerType.cost;
                updateUI();
            }
        }
        
        function isValidTowerPosition(x, y) {
            for (let point of path) {
                const dist = Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
                if (dist < 35) return false;
            }
            
            for (let tower of gameState.towers) {
                const dist = Math.sqrt(Math.pow(tower.x - x, 2) + Math.pow(tower.y - y, 2));
                if (dist < 45) return false;
            }
            
            return true;
        }
        
        function spawnEnemy() {
            if (!gameState.gameRunning || !gameState.waveInProgress) return;
            
            if (gameState.enemiesSpawned < gameState.enemiesInWave) {
                let enemyType = 'basic';
                const availableTypes = Object.keys(enemyTypes).filter(type => 
                    enemyTypes[type].unlocked || gameState.wave >= enemyTypes[type].unlockWave
                );
                
                if (gameState.wave % 25 === 0 && gameState.wave >= 25) {
                    enemyType = 'boss';
                } else {
                    const normalTypes = availableTypes.filter(type => type !== 'boss');
                    
                    const weights = normalTypes.map(type => {
                        if (type === 'basic') return 3;
                        return Math.max(1, gameState.wave - (enemyTypes[type].unlockWave || 1) + 1);
                    });
                    const totalWeight = weights.reduce((a, b) => a + b, 0);
                    let random = Math.random() * totalWeight;
                    for (let i = 0; i < normalTypes.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            enemyType = normalTypes[i];
                            break;
                        }
                    }
                }
                
                gameState.enemies.push(new Enemy(enemyType));
                gameState.enemiesSpawned++;
            }
        }
        
        function startWave() {
            if (gameState.waveInProgress) return;
            
            Object.keys(enemyTypes).forEach(type => {
                if (!enemyTypes[type].unlocked && gameState.wave >= (enemyTypes[type].unlockWave || 1)) {
                    enemyTypes[type].unlocked = true;
                    showUnlockMessage(`New Enemy: ${type.toUpperCase()}!`);
                }
            });
            
            Object.keys(towerTypes).forEach(type => {
                if (!towerTypes[type].unlocked && gameState.wave >= (towerTypes[type].unlockWave || 1)) {
                    towerTypes[type].unlocked = true;
                    showUnlockMessage(`New Tower: ${type.toUpperCase()}!`);
                }
            });
            
            updateTowerUI();
            
            gameState.waveInProgress = true;
            gameState.enemiesSpawned = 0;
            
            if (gameState.wave % 25 === 0 && gameState.wave >= 25) {
                gameState.enemiesInWave = 1;
                showUnlockMessage(`üî• BOSS WAVE ${gameState.wave}! üî•`);
            } else {
                gameState.enemiesInWave = 8 + gameState.wave * 3;
            }
            
            gameState.gameRunning = true;
            
            let spawnDelay;
            if (gameState.wave % 25 === 0 && gameState.wave >= 25) {
                spawnDelay = 2000;
            } else {
                spawnDelay = Math.max(400, 1100 - gameState.wave * 80);
            }
            
            const spawnInterval = setInterval(() => {
                if (!gameState.gameRunning) {
                    clearInterval(spawnInterval);
                    return;
                }
                
                if (gameState.enemiesSpawned < gameState.enemiesInWave && !gameState.paused) {
                    spawnEnemy();
                } else if (gameState.enemies.length === 0 && gameState.enemiesSpawned >= gameState.enemiesInWave) {
                    gameState.wave++;
                    gameState.waveInProgress = false;
                    
                    let goldBonus = 25 + gameState.wave * 8;
                    if ((gameState.wave - 1) % 25 === 0 && gameState.wave > 25) {
                        goldBonus *= 3;
                        showUnlockMessage(`üí∞ BOSS DEFEATED! Triple Gold Bonus! üí∞`);
                    }
                    
                    gameState.gold += goldBonus;
                    clearInterval(spawnInterval);
                    updateUI();
                }
            }, spawnDelay);
        }
        
        function showUnlockMessage(message) {
            const notification = document.createElement('div');
            notification.textContent = message;
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(145deg, #2ecc71, #27ae60);
                color: white;
                padding: 20px 40px;
                border-radius: 10px;
                font-size: 18px;
                font-weight: bold;
                z-index: 1000;
                box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                animation: fadeInOut 3s ease-in-out;
            `;
            
            if (message.includes('BOSS')) {
                notification.style.background = 'linear-gradient(145deg, #e74c3c, #c0392b)';
                notification.style.fontSize = '24px';
                notification.style.textShadow = '2px 2px 4px rgba(0,0,0,0.5)';
            }
            
            document.body.appendChild(notification);
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 3000);
        }
        
        function updateTowerUI() {
            const towersContainer = document.getElementById('towersContainer');
            towersContainer.innerHTML = '';
            
            Object.keys(towerTypes).forEach(type => {
                const tower = towerTypes[type];
                if (tower.unlocked) {
                    const button = document.createElement('button');
                    button.className = `tower-btn ${type}`;
                    button.onclick = () => selectTower(type);
                    
                    const emoji = {
                        cannon: 'üè∞',
                        laser: 'üîµ',
                        missile: 'üöÄ',
                        sniper: 'üéØ',
                        freeze: '‚ùÑÔ∏è',
                        plasma: '‚≠ê',
                        electric: '‚ö°',
                        poison: '‚ò†Ô∏è'
                    }[type];
                    
                    button.textContent = `${emoji} ${type.charAt(0).toUpperCase() + type.slice(1)} (${tower.cost})`;
                    towersContainer.appendChild(button);
                }
            });
        }
        
        function togglePause() {
            gameState.paused = !gameState.paused;
            document.querySelector('#controls button:nth-child(2)').textContent = 
                gameState.paused ? '‚ñ∂Ô∏è Resume' : '‚è∏Ô∏è Pause';
        }
        
        function resetGame() {
            gameState = {
                gold: 75,
                lives: 20,
                wave: 1,
                selectedTower: null,
                selectedPlacedTower: null,
                enemies: [],
                towers: [],
                projectiles: [],
                particles: [],
                lightningEffects: [],
                gameRunning: false,
                paused: false,
                waveInProgress: false,
                enemiesSpawned: 0,
                enemiesInWave: 8
            };
            
            Object.keys(enemyTypes).forEach(type => {
                enemyTypes[type].unlocked = type === 'basic';
            });
            Object.keys(towerTypes).forEach(type => {
                towerTypes[type].unlocked = ['cannon', 'laser', 'missile', 'sniper'].includes(type);
            });
            
            updateUI();
            updateTowerButtons();
            updateTowerControls();
            updateTowerUI();
        }
        
        function updateUI() {
            document.getElementById('gold').textContent = gameState.gold;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('enemies').textContent = gameState.enemies.length;
        }
        
        function drawPath() {
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.8)';
            ctx.lineWidth = 25;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            
            ctx.strokeStyle = '#8b4513';
            ctx.lineWidth = 30;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (!gameState.paused) {
                gameState.enemies = gameState.enemies.filter(enemy => enemy.update());
                gameState.towers.forEach(tower => tower.update());
                gameState.projectiles = gameState.projectiles.filter(projectile => projectile.update());
                gameState.particles = gameState.particles.filter(particle => particle.update());
                gameState.lightningEffects = gameState.lightningEffects.filter(effect => effect.update());
            }
            
            drawPath();
            
            gameState.enemies.forEach(enemy => enemy.draw());
            gameState.towers.forEach(tower => tower.draw());
            gameState.projectiles.forEach(projectile => projectile.draw());
            gameState.particles.forEach(particle => particle.draw());
            gameState.lightningEffects.forEach(effect => effect.draw());
            
            updateUI();
            updateTowerControls();
            requestAnimationFrame(gameLoop);
        }
        
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            placeTower(x, y);
        });
        
        window.addEventListener('load', function() {
            updateUI();
            updateTowerControls();
            updateTowerUI();
            gameLoop();
        });
    </script>
</body>
</html>
